# 面试遇到的问题

## js中闭包、异步编程、事件循环的概念，并给出实际应用的例子

* 闭包：允许函数捕获其作用域外的变量
	* 数据封装：闭包可以用来创建私有变量，使外部无法直接访问
	* 记忆化：可以存储计算结果，提高性能
* 异步编程是一种允许程序在等待某些操作完成时继续执行其他任务的方法。js中可以通过回调、promise、async/await实现
	* 网络请求，不阻塞UI渲染
	* 事件处理，响应用户触摸、输入时，避免卡顿
* 事件循环是js处理异步操作的机制，能使其在单线程中执行异步代码。它通过调用栈和事件队列协作，管理任务的执行顺序。
	* 用户交互：保证在用户操作界面时不会出现阻塞
	* 定时任务：如定时器和动画

## Object.freeze 与Immutable.js
都是用来处理不可变数据的技术。

`Object.freeze()`是js内置方法用于浅冻结对象，只会冻结对象的顶层属性。
对象中的某个属性是另一个对象或数组，那么这个内部的对象或数组仍然是可变的。
对于简单的对象和少量的数据性能较好。
**案例**
```
const person = {
  name: 'Alice',
  address: {
    city: 'Wonderland'
  }
};
// 浅冻结
Object.freeze(person);

person.name = 'Bob'; // 不起作用
person.address.city = 'Oz'; // 起作用，因为 address 对象没有被冻结
console.log(person); // { name: 'Alice', address: { city: 'Oz' } }
// 修改可新建对象
const newPerson = {...persion}

```

`Immutable.js`是三方库，提供的数据结构是深层不可变的。提供大量方法操作数据结构，它们不会改变原数据，而是返回新的实例。通过结构共享高效重用内存。
适用于深度不可变，结构复杂、数据量较大大、操作频繁、状态管理和高性能计算等场景。

## 如何利用浏览器缓存提升性能

* 设置缓存策略
  * 利用http头信息来控制资源的缓存行为，请求size是memory cache 和 disk cache就表示，浏览器并没有向服务器发送请求，而是直接读取了本地的缓存资源文件。

  * 缓存过程分为[强缓存和协商缓存](./Xi.Blog/2022/计算机及浏览器基础/浏览器的缓存机制.md)
  * 强缓存不会向服务器发送请求，直接从缓存中读取资源，请求头需设置`Cache-Control`并设置缓存时长，在这个时间内都读取缓存即使服务器资源文件发生变化。
	* 协商缓存就是强缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程。请求头通过设置`Last-Modified`或者`ETag`实现
* 资源版本化
	* 对静态资源版本化，当资源发生变化后，通过改变文件名来通知浏览器，忽略旧缓存获取新版本。
* 使用service worker
	* 使用Service Workers拦截请求实现离线缓存和更灵活的缓存策略，可以精细控制如何处理网络请求和缓存响应。
* 利用浏览器的本地缓存
	* 利用localStorage、index DB来存储一些需要快速访问的数据，减少服务器请求次数。
* 资源压缩与合并
	* 压缩静态资源（如使用Gzip）减小文件大小，加快加载速度。
	* 合并多个CSS或JavaScript文件，减少HTTP请求次数

## 数组平铺算法
```
function flattenArr(arr = []) {
    let reslutArr = []
    let _arr = arr;
    for (const obj of _arr) {
        if(Array.isArray(obj)) {
            reslutArr.push(...flattenArr(obj)) 
        }else {
            reslutArr.push(obj)
        }
    }

    return reslutArr;
}

var arr = [1, [2, [3, [4]]], [5, 6], 7, [8, 9]];
var newArr = flattenArr(arr);
console.log(newArr);
// [1, 2, 3, 4, 5, 6，7, 8, 9]

```

## 输出结果
```
setTimeout(() => {
    console.log('setTimeout')
})

new Promise((resolve) => {
    console.log('Promise1')
    resolve()
}).then(() => {
    console.log('then1')
})

new Promise((resolve) => {
    console.log('Promise2')
    resolve()
}).then(() => {
    console.log('then2')
})

// Promise1 Promise2 then1 then2 setTimeout

```


## 函数组件，props传入结束的时间戳，显示距离此结束时间的倒计时，同时会有暂停和重新开始的两个按钮

```
function Countdown(props) {
  const [countdown, setCountdown] = useState(props.endTime - Date.now());
  const [paused, setPaused] = useState(false);
  const intervalRef = useRef(null);

  useEffect(() => {
    if (!paused) {
        intervalRef.cuttent && clearInterval(intervalRef.cuttent);
    }else {
        intervalRef.cuttent = setInterval(() => {
            setCountdown(props.endTime - Date.now());
          }, 1000);
    }

    return () => clearInterval(intervalRef.cuttent);
  }, [props.endTime, paused]);

  const formatTime = useMemo(()=>{
    const hours = Math.floor(countdown / 3600000);
    const minutes = Math.floor((countdown % 3600000) / 60000);
    const seconds = Math.floor((countdown % 60000) / 1000);
    return `${hours.toString().padStart(2, "0")}:${minutes
      .toString().padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`
  },[countdown])

  return (
    <div>
      <p>{formatTime}</p>
      <button onClick={() => setPaused(!paused)}>
        {paused ? "Resume" : "Pause"}
      </button>
    </div>
  )
}

```

