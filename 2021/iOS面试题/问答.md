# 问答

## 声明block时为什么使用copy,而不是用weak，strong，assign ?

block存储区域有：_NSConcretStackBlock在栈上、_NSConcretGlobalBlock全局的、_NSConcretMallocBlock在堆上。
```
void (^block)() = ^{
       
 };
block();
```
这种是定义在Global全局的的block。不采用@property声明的block，在方法内使用的都是全局的。

copy是把block拷贝到堆上，在ARC模式下也可使用strong，和copy效果一样都是拷贝到堆上，是存储在_NSConcretMallocBlock上。

weak和assign都是在栈上分配的内存，执行完之后就会被释放掉。是存储在_NSConcretStackBlock在栈上的。

## 魔幻迷题

下面代码有什么不同，执行结果如何？

```
	dispatch_queue_t queue = dispatch_get_global_queue(0, 0);
    
    for (int i = 0; i < 1000; i++) {
        dispatch_async(queue, ^{
            self.name = [NSString stringWithFormat:@"abcdefghijk"];
        });
    }
    
    for (int i = 0; i < 1000; i++) {
        dispatch_async(queue, ^{
            self.name = [NSString stringWithFormat:@"abc"];
        });
    }
```
  
答案：第一个for循环会crash,第二个可以正常执行

**分析：**

* 第一个crash的原因：
 
  `self.name = xxx;`其实是调用`setName:`方法。
   方法的内部实现伪代码如下：
   
   ```
   -(void)setName:(NSString *)name {
	    if (_name != name) {
	        [_name release];
	        _name = [name copy];
	    }
	}
   ``` 
   
 多线程异步并发调用,将导致线程不安全。
 可能有多个线程同时调用`[_name release];`方法。
 当`-name`的引用计数已经为0，再`release`就会引发crash。
 解决方案对赋值操作加锁处理，例如：`@synchronized (self){}`

* 第二个为什么没有crash
 
 我们打印`self.name`的类型发现他是`NSTaggedPointerString`这个类型，而不是`__NSCFString`类型。这就是问题的关键，系统利用TaggedPointer可以存储小数据的特点做了优化。直接将数据转成ASCII码存在地址中（大概最多存9个字符），TaggedPointer不是OC对象不会调用`release`方法。

## 多个异步线程，如何让第一个线程弹出一个框，让最后一个线程取消弹框？异步线程操作问题

(1).第一种：
```
dispatch_group_t group =  dispatch_group_create();

dispatch_group_async(group,dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    // 执行1个耗时的异步操作
});

dispatch_group_async(group,dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    // 执行1个耗时的异步操作
});

dispatch_group_notify(group, dispatch_get_main_queue(), ^{
    // 等前面的异步操作都执行完毕后，回到主线程...
});
```
2).第二种：
```
dispatch_group_t serviceGroup = dispatch_group_create();
dispatch_group_enter(serviceGroup);
//请求一：
blockSuccessed:^{
dispatch_group_leave(serviceGroup);
}failed:^{
dispatch_group_leave(serviceGroup);
}
//请求二：
blockSuccessed:^{
dispatch_group_leave(serviceGroup);
}failed:^{
dispatch_group_leave(serviceGroup);
}
dispatch_group_notify(serviceGroup, dispatch_get_main_queue(), ^{
          // 异步请求每次执行dispatch_group_leave时，都回到主线程..，否则会一直处在信号等待中
        });
```
(3).第三种可实现异步顺序输出：
    异步串行，信号量，锁机制。

## 队列的使用

NSOperation进阶使用：[https://juejin.im/post/5bf89cc5518825719f209144](https://juejin.im/post/5bf89cc5518825719f209144)

### GCD和NSOperation

* GCD是苹果公司为多核的并行运算提出的解决方案，会自动利用更多的CPU内核(比如双核、四核)，而NSOperation是基于GCD的面向对象的封装，拥有GCD的特性。
* GCD是将任务(block)添加到队列(串行/并行/全局/主队列),并且以同步/异步的方式执行任务的函数，而NSOperation将操作(一般是异步的任务)添加到队列(一般是并发队列),就会执行指定操作的函数。
* 相对于NSThread或者是跨平台的pthread而言，GCD和NSOperation都是自动管理线程的生命周期，开发者只要专注于具体任务逻辑,不需要编写任何线程管理相关的代码。

**区别:**

1. GCD提供了一些NSOperation不具备的功能：延迟执行、一次性执行、调度组；
2. NSOperation里提供了一些方便的操作：最大并发数、 队列的暂停/继续、取消所有的操作、指定操作之间的依赖关系(GCD可以用同步实现功能)；
3. GCD是无法控制线程的最大并发数的，而NSOperation可以设置最大并发数，可以灵活的根据需要限制线程的个数。因为开辟线程需要消耗必要的资源。

**何时使用GCD:**
调度队列(Dispatch queues)、分组(groups)、信号量(semaphores)、栅栏(barriers)组成了一组基本的并发原语。对于一次性执行，或者简单地加快现有方法的速度，使用轻量级的GCD分派(dispatch)比使用NSOperation更方便。

**何时使用NSOperation:**
在特定队列优先级和服务质量(用于表示工作对系统的性质和重要性)下， 可以用一系列依赖来调度NSOperation对象 。与在GCD队列上调度的block不同，NSOperation可以被取消和查询其操作状态。通过子类化，NSOperation可以关联执行结果，以供之后参考。

**注意：**NSOperation和GCD不是互斥的。

## dispatch_semaphore信号量

1. 信号量的初始值，可以用来控制线程并发访问的最大数量
2. 信号量的初始值为1，代表同时只允许1条线程访问资源，保证线程同步
3. 如果信号量的值<=0,当前线程就会进入休眠等待（直到信号量的值>0，被唤醒）
4. `dispatch_semaphore_wait`如果信号量值>0,就会减1
5. `dispatch_semaphore_signal`让信号量的值加1

## 读写安全方案
思考如何实现以下场景:

1. 同一时间，只能有1个线程进行写的操作
2. 同一时间，允许有多个线程进行读的操作
3. 同一时间，不允许既有写的操作又有读的操作

**分析：**
上面的场景就是典型的“多读单写”，经常用于文件等数据的读写操作，iOS中的实现方案有：

1. `pthread_rwlock`:读写锁
2. `dispatch_barrier_async`: 异步栅栏调用，此处传入的队列必须是创建的并行队列，不能是串行或全局队列。如果是串行或全局队列则效果等同于`dispatch_async`


## 自旋锁、互斥锁比较

1. 什么情况下使用自旋锁比较划算？
 * 预计线程等待锁的时间很短
 * 加锁的代码（临界区）经常被调用，但竞争情况很少发生
 * CPU资源不紧张
 * 支持多核处理器

2. 什么情况下使用互斥锁比较划算？
 * 预计线程等待锁的时间较长
 * 仅支持单核处理器
 * 临界区有IO操作
 * 临界区代码复杂或者循环量大
 * 临界区竞争非常激烈

## +load和+initialize方法

### +load
1. +load方法会在runtime加载**类**、**分类**时调用
2. 每个**类**、**分类**的+load方法，在程序运行过程中只调用一次
3. 调用顺序：
	* 先调用类的+load
		* 按照编译先后顺序调用（先编译，先调用）
		* 调用子类的+load之前会先调用父类的+load
		
	* 再调用分类烦的+load方法
	  按照编译先后顺序调用（先编译的先调用）

### +initialize

1. +initialize方法会在**类**第一次接收到消息时调用
2. 调用顺序：先调用父类的+initialize方法，再调用子类的+initialize
3. 如果分类实现了+initialize,就会覆盖本类的+initialize方法

### load、initialize方法的区别？

**调用方式**

1. load是根据函数地址直接调用
2. initialize是通过objc_msgSend调用

**调用时刻**

1. load是runtime加载类、分类的时候调用（只会调用一次）
2. initialize是类第一次接收到消息的时候调用，每个类只会initialize一次（父类的initialize可能被调用多次）

## KVC

**setValue:forKey:**的原理：
1. `setValue:forKey:` -> 按照`setKey`、`_setKey`的顺序查找方法，找到则调用方法
2. 没找到则查看`accessInstanceVariablesDirectly`方法的返回值
3. 返回YES则，按照`_key`,`_isKey`,`key`,`isKey`的顺序查找成员变量，找到后直接赋值
4. 若`accessInstanceVariablesDirectly`方法的返回NO或没有找到第三步中的成员变量，则调用`setValue:forUndefinedKey:`并抛出异常NSUnknownKeyException

**valueForKey:**的原理：
1. `valueForKey:`按照`getKey`,`key`,`isKey`,`_key`顺序查找方法，找到则直接调用方法
2. 没找到，则查看`accessInstanceVariablesDirectly`方法的返回值
3. 返回YES则，按照`_key`,`_isKey`,`key`,`isKey`的顺序查找成员变量，找到后直接取值
4. 若`accessInstanceVariablesDirectly`方法的返回NO或没有找到第三步中的成员变量，则调用`valueforUndefinedKey:`并抛出异常NSUnknownKeyException


## 一个NSObject对象占用多少内存？

1. 系统分配了16个字节给NSObject对象（通过malloc_size函数获得）
2. 但是NSObject对象内部只使用了8个字节的空间（64bit环境下，可以通过class_getInstanceSize函数获得）

## 对象的isa指针指向哪里？

1. instance对象的isa指向class对象
2. class对象的isa执行meta-class对象
3. meta-class对象的isa执行基类meta-class对象

## OC的类信息存放在哪里？
1. 对象方法、属性、成员变量、协议信息，存放在class类对象中
2. 类方法，存储在meta-class对象中
3. 成员变量的具体值，存放在instanc对象

## struct 和 class 的区别？

区别：

1. 类可以继承，结构体不可以
2. 可以让一个类的实例来反初始化，释放存储空间，结构体做不到
3. 类的对象是引用类型，而结构体是值类型。所以类的赋值是传递引用 ，结构体则是传值。

相同点：

1. 类和结构体都可以扩展
2. 定义属性用于储存值
3. 定义方法用于提供功能
4. 定义下标用于通过下标语法访问值
5. 定义初始化器用于生成初始化值

## class与staitc关键字的区别

1. static 可以在类、结构体、或者枚举中使用。而 class 只能在类中使用。
2. static 可以修饰存储属性，static 修饰的存储属性称为静态变量(常量)。而 class 不能修饰存储属性。
3. static 修饰的计算属性不能被重写。而 class 修饰的可以被重写。
4. static 修饰的静态方法不能被重写。而 class 修饰的类方法可以被重写。
5. class 修饰的计算属性被重写时，可以使用 static 让其变为静态属性。 f. class 修饰的类方法被重写时，可以使用 static 让方法变为静态方法。


## 下面代码在arc和mrc下输出什么？

```
void pr(int (^block)(void)){
    printf("%d\n %p\n",block(),block);
}
void func() {
    int (^blocks[10])(void);
    int i;
    for (i=0; i<10; i++) {
        blocks[i]=^{
            return i;
        };
    }
    for (int j = 0; j<10; j++) {
        pr(blocks[j]);
    }
}

int main(int argc, char * argv[]) {
    @autoreleasepool {
        //arc0-9和mrc10个9结果不同，
        //mrc时赋值那里加 copy,把block从stackblock栈上copy到mallocblock堆上
        func();
        return 0;
    }
}
```

## 下面代码输出什么？
```
@interface PP: NSObject
@end

@implementation PP

@end
@property (nonatomic, strong) NSString *strongString;
@property (nonatomic, weak)   NSString *weakString;

@property (nonatomic, strong) PP *strongPP;
@property (nonatomic, weak)   PP *weakPP;

_strongString = @"string1";
_weakString =  _strongString;

_strongString = nil;
   
NSLog(@"=%@", _weakString);//=string1
   
_strongPP = [[PP alloc] init];
_weakPP = _strongPP;
_strongPP = nil;
NSLog(@"==%@",_weakPP);//==nil

```

## performSelector系列方法

```
-(void)currentLoop {
   
    //该方法是单线程的只在主线程执行，也就是说只有当前调用此方法的函数执行完毕后，selector方法才会被调用
    [self performSelector:@selector(test2:) withObject:@"test1" afterDelay:3];
   
    //在主线程中运行方法，wait表示是否阻塞这个方法的调用，如果为YES则等待主线程中test方法运行结束然后再继续向下执行
    [self performSelectorOnMainThread:@selector(test3:) withObject:@"test2" waitUntilDone:YES];
    [self performSelectorOnMainThread:@selector(test4:) withObject:@"test3" waitUntilDone:NO];
    //是多线程方法,会产生新的线程
    [self performSelectorInBackground:@selector(test5:) withObject:@"test4"];
   
    [self performSelector:@selector(test1:) withObject:@"test5"];
    NSLog(@"-----------------sleep前");
    sleep(5);
    NSLog(@"-----------------sleep后");
}
-(void)test1:(id)sender {
    NSLog(@"%@-%@-%p",sender,[NSThread currentThread],[NSRunLoop currentRunLoop]);
}
-(void)test2:(id)sender {
    NSLog(@"%@-%@-%p",sender,[NSThread currentThread],[NSRunLoop currentRunLoop]);
}
-(void)test3:(id)sender {
    NSLog(@"%@-%@-%p",sender,[NSThread currentThread],[NSRunLoop currentRunLoop]);
}
-(void)test4:(id)sender {
    NSLog(@"%@-%@-%p",sender,[NSThread currentThread],[NSRunLoop currentRunLoop]);
}
-(void)test5:(id)sender {
    NSLog(@"%@-%@-%p",sender,[NSThread currentThread],[NSRunLoop currentRunLoop]);
}
/ *
  test2-{number = 1, name = main}-0x6000009973c0
  test5-{number = 1, name = main}-0x6000009973c0
  -----------------sleep前
  test4-{number = 3, name = (null)}-0x60000099ea60
  -----------------sleep后
  test3-{number = 1, name = main}-0x6000009973c0
  test1-{number = 1, name = main}-0x6000009973c0
 * / 
```
 
## @synthesize和@synchronized
 
锁：https://www.jianshu.com/p/b1edc6b0937a
高效的同步锁：https://www.jianshu.com/p/306481753216

`@synthesize`:表示如果属性没有手动实现setter和getter方法，编译器会自动加上这两个方法。
`@synchronized(self)`:作用是创建一个互斥锁，保证此时没有其它线程对self对象进行修改。

互斥锁的作用：防止self对象在同一时间内被其它线程访问，起到线程的保护作用；
互斥锁的优点：能有效防止因多线程抢占资源造成的数据安全问题。
缺点：需要消耗大量的cpu资源；
互斥锁使用了线程同步的技术，即多条线程在同一条线上顺序的执行。
@synchronized block 内部实现：
会变成 `objc_sync_enter` 和 `objc_sync_exit` 的成对儿调用:
```
@synchronized(obj) {
    // do work
}
```
转化成：
```
@try {
    objc_sync_enter(obj);
    // do work
} @finally {
    objc_sync_exit(obj);    
}
```

## iOS中id和NSObject ,instancetype的区别？

返回类型：

1. id非关联返回类型，得到的返回类型就和方法声明的返回类型一样
2. instancetype得到的返回类型和方法所在类的类型相同,instancetype的作用，就是使那些非关联返回类型的方法返回所在类的类型！

instancetype和id区别：

1. id在编译的时候不能判断对象的真实类型instancetype在编译的时候可以判断对象的真实类型。
2. 如果init方法的返回值是instancetype,那么将返回值赋值给一个其它的对象会报一个警告如果是在以前, init的返回值是id,那么将init返回的对象地址赋值给其它对象是不会报错的
3. id可以用来定义变量, 可以作为返回值, 可以作为形参instancetype只能用于作为返回值
**注意**：以后但凡自定义构造方法, 返回值尽量使用instancetype, 不要使用id

NSObject和id区别:

1. NSObject包含了一些其他的方法，需要实现NSObject协议，可以用NSObject来表示id，但是不能用id来表示NSObject
2. id可以是任何对象，包括不是NSObject的对象
3. 定义id的时候不需要*，而定义NSOject的时候需要
4. id是个指针，任意类型的指针。它简单地申明了指向对象的指针，没有给编译器任何类型信息
5. 不是所有的Foundation/Cocoa对象都继承息NSObject，比如NSProxy就不从NSObject继承，所以你无法使用NSObject＊指向这个对象，即使NSProxy对象有release和retain这样的通用方法



## app被拒问题总结

(1).需要登录时，提供的账号密码不对，或测试账号被删除，审核无法登录
(2).手机号验证码登录，需要提供手机号和固定的验证码
(3).引用第三方不合法链接，引起的盗版商店问题，例如：引入同步推（tongbu.com）有关链接
(4).内购。购买虚拟商品！之前没有问题的。
(5).app内有上报用户个人信息的功能，有可能被拒！属于恶意收集用户隐私行为
(6).上架相同的产品，例如：普通版和专业版这种，需要提供其不同之处！
(7).定位权限描述用于干什么的，没有描述清楚
(8).宣传图和内容不符,6.5寸的宣传图中展示有ihopne6的模版。

## GIF图片转换
```
#pragma mark 转换图片，如果是gif则计算动画时长
UIImage *getImageWithData(NSData *data) {
    CGImageSourceRef imageSource = CGImageSourceCreateWithData((__bridge CFDataRef)data, NULL);
    size_t count = CGImageSourceGetCount(imageSource);
    if (count <= 1) { //非gif
        CFRelease(imageSource);
        return [[UIImage alloc] initWithData:data];
    } else { //gif图片
        NSMutableArray *images = [NSMutableArray array];
        NSTimeInterval duration = 0;
        for (size_t i = 0; i < count; i++) {
            CGImageRef image = CGImageSourceCreateImageAtIndex(imageSource, i, NULL);
            if (!image) continue;
            duration += durationWithSourceAtIndex(imageSource, i);
            [images addObject:[UIImage imageWithCGImage:image]];
            CGImageRelease(image);
        }
        if (!duration) duration = 0.1 * count;
        CFRelease(imageSource);
        return [UIImage animatedImageWithImages:images duration:duration];
    }
}
#pragma mark 获取每一帧图片的时长
float durationWithSourceAtIndex(CGImageSourceRef source, NSUInteger index) {
    float duration = 0.1f;
    CFDictionaryRef propertiesRef = CGImageSourceCopyPropertiesAtIndex(source, index, nil);
    NSDictionary *properties = (__bridge NSDictionary *)propertiesRef;
    NSDictionary *gifProperties = properties[(NSString *)kCGImagePropertyGIFDictionary];
   
    NSNumber *delayTime = gifProperties[(NSString *)kCGImagePropertyGIFUnclampedDelayTime];
    if (delayTime) duration = delayTime.floatValue;
    else {
        delayTime = gifProperties[(NSString *)kCGImagePropertyGIFDelayTime];
        if (delayTime) duration = delayTime.floatValue;
    }
    CFRelease(propertiesRef);
    return duration;
}
```

## 做IM开发时,有个场景是:

数据异步处理,回到主线程刷新UI、展示消息给用户看到.当用户短时间内收到很多条消息时,我们不想对UI进行频繁而累赘的更新,理想的情况是当主线程繁忙时将所有的改变联结起来。此时,可以利用联结的优势(在异步线程上调用 `dispatch_source_merge_data` 后，就会执行 dispatch source 事先定义好的 handler )。使用 `DISPATCH_SOURCE_TYPE_DATA_ADD`，将刷新UI的工作拼接起来，短时间内做尽量少次数的刷新。

伪代码：
```
-(void)merge_data_refresh_ui {
    dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_DATA_ADD, 0, 0, dispatch_get_main_queue());
    dispatch_source_set_event_handler(source, ^{
        //todo
        NSLog(@"data = %@",@(dispatch_source_get_data(source)));
        NSLog(@"刷新UI");
    });
    
    dispatch_resume(source);
    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    //第一个参数是循环次数
        dispatch_apply(10, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^(size_t index) {
            //todo
            NSLog(@"收到消息index = %@",@(index));
            dispatch_source_merge_data(source, 1);
        });
    });

    
}
```
执行结果:
收到消息index = 3
收到消息index = 2
收到消息index = 1
收到消息index = 0
收到消息index = 4
收到消息index = 5
收到消息index = 7
收到消息index = 6
收到消息index = 8
data = 1
收到消息index = 9
刷新UI
data = 9
刷新UI

另外一种伪代码：
```
-(void)setup_dispatch_source {
    if (!source) {
        source = dispatch_source_create(DISPATCH_SOURCE_TYPE_DATA_ADD, 0, 0, dispatch_get_main_queue());
        dispatch_source_set_event_handler(source, ^{
            //todo
            NSLog(@"data = %@",@(dispatch_source_get_data(source)));
            NSLog(@"刷新UI");
        });

    }
    
    dispatch_resume(source);
}
- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event {
    for (int i = 0; i < 5; i++) {
        [NSThread sleepForTimeInterval:0.3];
        dispatch_source_merge_data(source, 1);
    }
}
```
点击一下界面：
data = 5
刷新UI


