# 性能优化分析

## 查看PreMain启动时间

`Edit Scheme` ->`Run` -> `Arguments`->`Environment Variables`
点击`+`号，添加环境变量**DYLD_PRINT_STATISTICS**
如果需要更详细的信息，则添加**DYLD_PRINT_STATISTICS_DETAILE**,设置为1，默认为1

运行app,控制台将打印启动时间。

## 启动优化

查看代码编译流程：

1. Xcode设置
`Build Setting` -> 搜索`link map` -> 将`Write Link Map File` 设置为Yes

2. 重新编译后

	选中`Products`下的`xxx.app`，即应用的包。右键选择`Show in Finder`,选择上上层目录结构中的`Intermediates.noindex`->`XXX.build` -> `XXX-LinkMap-normal-x86_64.txt`
	
打开文件搜索`Symbols`,第一个下面的内容就是代码编译的顺序。

3. 二进制文件重排 
`Build Setting` -> 搜索`order file`,在此处设置重排的顺序，也可在此处引入重排的文件路径,例如：`./sort.order`

**疑问**：从上面可以看到，order文件排序就可以改变编译的顺序，那么怎么知道app首次启动都加载了哪些类和方法呢？？
方案1: 基于llvm插桩,使用AppOrderFiles工具
方案2: 基于llvm插桩
	简单来说 SanitizerCoverage 是 Clang 内置的一个代码覆盖工具。它把一系列以 `__sanitizer_cov_trace_pc_`为前缀的函数调用插入到用户定义的函数里，借此实现了全局 AOP 的大杀器。其覆盖之广，包含 Swift/Objective-C/C/C++ 等语言，Method/Function/Block 全支持。

开启 SanitizerCoverage 的方法是：在 build settings 里的 “Other C Flags”和“Other C++ Flags” 中添加 `-fsanitize-coverage=func,trace-pc-guard`。如果含有 Swift 代码的话，还需要在 “Other Swift Flags” 中加入 `-sanitize-coverage=func` 和 `-sanitize=undefined`。所有链接到 App 中的二进制都需要开启 SanitizerCoverage，这样才能完全覆盖到所有调用。

[代码实现](https://cloud.tencent.com/developer/article/1774441)如下:

```
#import <stdint.h>
#import <stdio.h>
#import <sanitizer/coverage_interface.h>
#import <libkern/OSAtomic.h>
#import <dlfcn.h>

void __sanitizer_cov_trace_pc_guard_init(uint32_t *start, uint32_t *stop) {
  static uint64_t N;  // Counter for the guards.
  if (start == stop || *start) return;  // Initialize only once.
//  printf("INIT: %p %p\n", start, stop);
  for (uint32_t *x = start; x < stop; x++)
    *x = (uint32_t)++N;  // Guards should start from 1.
}

void printInfo(void *PC) {
    Dl_info info;
    dladdr(PC, &info);
    printf("fnam:%s \n fbase:%p \n sname:%s \n saddr:%p \n",
           info.dli_fname,
           info.dli_fbase,
           info.dli_sname,
           info.dli_saddr);
}

static OSQueueHead symbolList = OS_ATOMIC_QUEUE_INIT;

typedef struct {
    void *pc;
    void *next;
} SymbolNode;

void __sanitizer_cov_trace_pc_guard(uint32_t *guard) {
    if (!*guard) return;  // Duplicate the guard check.
    
    void *PC = __builtin_return_address(0);
    
    SymbolNode * node = malloc(sizeof(SymbolNode));
    *node = (SymbolNode){PC, NULL};
    
    OSAtomicEnqueue(&symbolList, node, offsetof(SymbolNode, next));
//    printInfo(PC);
}

```

上述只是获取到对应的符号，我们需要将他们翻译出来:

```
+ (BOOL)exportSymbolsWithFilePath:(nonnull NSString *)filePath
{
    NSMutableArray <NSString *>* symbolNames = [NSMutableArray array];
    while (YES) {
        SymbolNode *node = OSAtomicDequeue(&symbolList, offsetof(SymbolNode, next));
        if (node == NULL) {
            break;
        }
        Dl_info info;
        dladdr(node->pc, &info);
        
        NSString * name = @(info.dli_sname);
        BOOL isObjc = [name hasPrefix:@"+["] || [name hasPrefix:@"-["]; // Objective-C method do nothing
        NSString * symbolName = isObjc? name : [@"_" stringByAppendingString:name]; // c function with "_"
        [symbolNames addObject:symbolName];
    }
    
    NSEnumerator * emt = [symbolNames reverseObjectEnumerator];
    NSMutableArray<NSString*>* funcs = [NSMutableArray arrayWithCapacity:symbolNames.count];
    NSString * name;
    while (name = [emt nextObject]) {
        if (![funcs containsObject:name]) {
            [funcs addObject:name];
        }
    }
    // remove current method symbol (not necessary when launch)
    [funcs removeObject:[NSString stringWithFormat:@"%s", __FUNCTION__]];
    
    NSString *funcStr = [funcs componentsJoinedByString:@"\n"];
    NSData * fileContents = [funcStr dataUsingEncoding:NSUTF8StringEncoding];
    if ([[NSFileManager defaultManager] fileExistsAtPath:filePath]) {
        [[NSFileManager defaultManager] removeItemAtPath:filePath error:nil];
    }
    return [[NSFileManager defaultManager] createFileAtPath:filePath contents:fileContents attributes:nil];
}

```
将上述函数写到
`- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions` 函数末尾即可获取到App启动到首屏显示所需要的符号


